<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Elliot</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Comic Sans MS', cursive, sans-serif;
        }

        #gameCanvas {
            border: 3px solid #4169E1;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            background: linear-gradient(to bottom, #87CEEB, #98FB98);
        }

        .game-container {
            position: relative;
        }

        .start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #4169E1;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
            z-index: 10;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="1200" height="600"></canvas>
        <div id="startScreen" class="start-screen">
            <h1>Flappy Elliot</h1>
            <p>Press any key to start flying!</p>
            <p style="font-size: 16px;">Arrow Keys: Move â€¢ Space: Sky Walk</p>
        </div>
    </div>
    <script>
        class ElliotsGame {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.startScreen = document.getElementById('startScreen');

        this.gameState = 'start';
        this.score = 0;
        this.level = 1;
        this.levelTime = 0;
        this.levelDuration = 60000;

        this.sounds = this.createSounds();

        this.keys = {};
        this.lastTime = 0;

        this.player = new Player(100, 300);
        this.clouds = [];
        this.obstacles = [];
        this.powerUps = [];
        this.platforms = [];

        this.setupEventListeners();
        this.generateLevel();
        this.gameLoop();
    }

    createSounds() {
        const audioContext = typeof AudioContext !== 'undefined' ? new AudioContext() : null;

        return {
            playTone: (frequency, duration, volume = 0.1) => {
                if (!audioContext) return;

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            },

            collectCloud: function() {
                this.playTone(523.25, 0.2, 0.1);
                setTimeout(() => this.playTone(659.25, 0.2, 0.1), 100);
            },

            powerUp: function() {
                this.playTone(440, 0.1, 0.1);
                setTimeout(() => this.playTone(554.37, 0.1, 0.1), 50);
                setTimeout(() => this.playTone(659.25, 0.2, 0.1), 100);
            },

            damage: function() {
                this.playTone(220, 0.3, 0.15);
            },

            playTone: function(frequency, duration, volume = 0.1) {
                if (!audioContext) return;

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            }
        };
    }

    setupEventListeners() {
        document.addEventListener('keydown', (e) => {
            this.keys[e.code] = true;
            if (this.gameState === 'start') {
                this.startGame();
            }
        });

        document.addEventListener('keyup', (e) => {
            this.keys[e.code] = false;
        });
    }

    startGame() {
        this.gameState = 'playing';
        this.startScreen.classList.add('hidden');
    }

    generateLevel() {
        this.clouds = [];
        this.obstacles = [];
        this.powerUps = [];

        for (let i = 0; i < 20; i++) {
            this.clouds.push(new Cloud(
                Math.random() * (this.canvas.width - 40) + 20,
                Math.random() * (this.canvas.height - 40) + 20
            ));
        }

        for (let i = 0; i < 8; i++) {
            if (Math.random() < 0.6) {
                this.obstacles.push(new Bird(
                    Math.random() * this.canvas.width,
                    Math.random() * (this.canvas.height - 100) + 50
                ));
            } else {
                this.obstacles.push(new Tornado(
                    Math.random() * this.canvas.width,
                    Math.random() * (this.canvas.height - 100) + 50
                ));
            }
        }

        for (let i = 0; i < 3; i++) {
            const powerUpType = Math.floor(Math.random() * 3);
            this.powerUps.push(new PowerUp(
                Math.random() * (this.canvas.width - 40) + 20,
                Math.random() * (this.canvas.height - 40) + 20,
                powerUpType
            ));
        }
    }

    update(deltaTime) {
        if (this.gameState !== 'playing') return;

        this.levelTime += deltaTime;

        this.player.update(deltaTime, this.keys, this.platforms);

        this.obstacles.forEach(obstacle => obstacle.update(deltaTime));

        this.platforms = this.platforms.filter(platform => platform.update(deltaTime));

        this.checkCollisions();

        if (this.levelTime >= this.levelDuration || this.clouds.length === 0) {
            this.nextLevel();
        }

        if (this.player.health <= 0) {
            this.gameOver();
        }
    }

    checkCollisions() {
        this.clouds = this.clouds.filter(cloud => {
            if (this.player.collidesWith(cloud)) {
                this.score++;
                this.createSparkles(cloud.x, cloud.y);
                this.sounds.collectCloud();
                return false;
            }
            return true;
        });

        this.powerUps = this.powerUps.filter(powerUp => {
            if (this.player.collidesWith(powerUp)) {
                this.player.activatePowerUp(powerUp.type);
                this.sounds.powerUp();
                return false;
            }
            return true;
        });

        if (!this.player.invincible && !this.player.invisible) {
            this.obstacles.forEach(obstacle => {
                if (this.player.collidesWith(obstacle) && !this.player.invulnerable) {
                    this.player.takeDamage();
                    this.sounds.damage();
                }
            });
        }
    }

    createSparkles(x, y) {
        for (let i = 0; i < 5; i++) {
            setTimeout(() => {
                this.ctx.save();
                this.ctx.globalAlpha = 1 - (i * 0.2);
                this.ctx.fillStyle = '#FFD700';
                this.ctx.beginPath();
                this.ctx.arc(x + (Math.random() - 0.5) * 30, y + (Math.random() - 0.5) * 30, 3, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }, i * 100);
        }
    }

    nextLevel() {
        this.level++;
        this.levelTime = 0;
        this.generateLevel();
        this.showLevelMessage(`Level ${this.level}!`);
    }

    showLevelMessage(message) {
        this.ctx.save();
        this.ctx.fillStyle = '#4169E1';
        this.ctx.font = 'bold 36px Comic Sans MS';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(message, this.canvas.width / 2, this.canvas.height / 2);
        this.ctx.restore();
    }

    gameOver() {
        this.gameState = 'gameOver';
        this.startScreen.innerHTML = `
            <h1>Game Over!</h1>
            <p>Score: ${this.score} clouds</p>
            <p>Level: ${this.level}</p>
            <p>Press any key to try again!</p>
        `;
        this.startScreen.classList.remove('hidden');

        this.score = 0;
        this.level = 1;
        this.levelTime = 0;
        this.player = new Player(100, 300);
        this.generateLevel();
        this.gameState = 'start';
    }

    render() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
        gradient.addColorStop(0, '#87CEEB');
        gradient.addColorStop(1, '#98FB98');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        if (this.gameState === 'playing') {
            this.clouds.forEach(cloud => cloud.render(this.ctx));
            this.powerUps.forEach(powerUp => powerUp.render(this.ctx));
            this.obstacles.forEach(obstacle => obstacle.render(this.ctx));
            this.platforms.forEach(platform => platform.render(this.ctx));
            this.player.render(this.ctx);
            this.renderUI();
        }
    }

    renderUI() {
        this.ctx.save();

        this.ctx.fillStyle = '#4169E1';
        this.ctx.font = 'bold 24px Comic Sans MS';
        this.ctx.fillText(`Score: ${this.score}`, 20, 40);
        this.ctx.fillText(`Level: ${this.level}`, 20, 70);

        this.ctx.fillStyle = '#FF69B4';
        this.ctx.fillText(`Mode: ${this.player.mode}`, 20, 100);

        for (let i = 0; i < this.player.health; i++) {
            this.drawHeart(200 + i * 35, 25);
        }

        this.ctx.restore();
    }

    drawHeart(x, y) {
        this.ctx.save();
        this.ctx.fillStyle = '#FF1493';
        this.ctx.beginPath();
        this.ctx.arc(x - 5, y, 8, 0, Math.PI * 2);
        this.ctx.arc(x + 5, y, 8, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.beginPath();
        this.ctx.moveTo(x - 12, y + 5);
        this.ctx.lineTo(x, y + 18);
        this.ctx.lineTo(x + 12, y + 5);
        this.ctx.fill();
        this.ctx.restore();
    }

    gameLoop(currentTime = 0) {
        const deltaTime = currentTime - this.lastTime;
        this.lastTime = currentTime;

        this.update(deltaTime);
        this.render();

        requestAnimationFrame((time) => this.gameLoop(time));
    }
}

class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 32;
        this.height = 32;
        this.vx = 0;
        this.vy = 0;
        this.speed = 200;
        this.health = 10;
        this.mode = 'Flying';
        this.invulnerable = false;
        this.invincible = false;
        this.invisible = false;
        this.speedBoost = false;
        this.powerUpTimer = 0;
    }

    update(deltaTime, keys, platforms) {
        const dt = deltaTime / 1000;
        let currentSpeed = this.speed;

        if (this.speedBoost) currentSpeed *= 1.5;

        this.vx = 0;
        this.vy = 0;

        if (keys['ArrowLeft']) this.vx = -currentSpeed;
        if (keys['ArrowRight']) this.vx = currentSpeed;

        if (this.mode === 'Flying') {
            if (keys['ArrowUp']) this.vy = -currentSpeed;
            if (keys['ArrowDown']) this.vy = currentSpeed;
        } else if (this.mode === 'Skydiving') {
            this.vy = currentSpeed * 1.5;
            if (keys['ArrowUp']) this.mode = 'Flying';
        } else if (this.mode === 'Sky Walking') {
            this.vy = 50;
            if (keys['ArrowUp']) {
                this.vy = -currentSpeed * 0.3;
            }
        }

        if (keys['Space'] && this.mode !== 'Sky Walking') {
            this.mode = 'Sky Walking';
            platforms.push(new Platform(this.x - 50, this.y + this.height));
        }

        if (keys['ArrowDown'] && this.mode !== 'Skydiving') {
            this.mode = 'Skydiving';
        }

        if (!keys['Space'] && !keys['ArrowDown'] && this.mode !== 'Flying') {
            this.mode = 'Flying';
        }

        this.x += this.vx * dt;
        this.y += this.vy * dt;

        this.x = Math.max(0, Math.min(this.x, 1200 - this.width));
        this.y = Math.max(0, Math.min(this.y, 600 - this.height));

        if (this.powerUpTimer > 0) {
            this.powerUpTimer -= deltaTime;
            if (this.powerUpTimer <= 0) {
                this.invincible = false;
                this.invisible = false;
                this.speedBoost = false;
            }
        }

        if (this.invulnerable) {
            setTimeout(() => this.invulnerable = false, 1500);
        }
    }

    render(ctx) {
        ctx.save();

        if (this.invisible) ctx.globalAlpha = 0.3;
        if (this.invincible) {
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#FFD700';
        }
        if (this.speedBoost) {
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00BFFF';
        }
        if (this.invulnerable) {
            ctx.globalAlpha = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;
        }

        ctx.fillStyle = '#8B4513';
        ctx.fillRect(this.x + 8, this.y + 5, 16, 20);

        ctx.fillStyle = '#FFE4B5';
        ctx.fillRect(this.x + 6, this.y, 20, 15);

        ctx.fillStyle = '#FFD700';
        ctx.fillRect(this.x + 8, this.y - 3, 16, 8);

        ctx.fillStyle = '#000';
        ctx.fillRect(this.x + 10, this.y + 3, 2, 2);
        ctx.fillRect(this.x + 20, this.y + 3, 2, 2);

        ctx.fillStyle = '#FF69B4';
        ctx.fillRect(this.x + 14, this.y + 7, 4, 1);

        if (this.mode === 'Flying') {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(this.x - 5, this.y + 10, 10, 3);
            ctx.fillRect(this.x + 27, this.y + 10, 10, 3);
        }

        ctx.fillStyle = '#00008B';
        ctx.fillRect(this.x + 6, this.y + 15, 20, 10);

        ctx.fillStyle = '#8B4513';
        ctx.fillRect(this.x + 8, this.y + 25, 6, 7);
        ctx.fillRect(this.x + 18, this.y + 25, 6, 7);

        ctx.restore();
    }

    collidesWith(object) {
        return this.x < object.x + object.width &&
               this.x + this.width > object.x &&
               this.y < object.y + object.height &&
               this.y + this.height > object.y;
    }

    takeDamage() {
        if (!this.invulnerable) {
            this.health--;
            this.invulnerable = true;
        }
    }

    activatePowerUp(type) {
        this.powerUpTimer = 7000;
        if (type === 0) this.speedBoost = true;
        else if (type === 1) this.invincible = true;
        else if (type === 2) this.invisible = true;
    }
}

class Cloud {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 40;
        this.height = 25;
    }

    render(ctx) {
        ctx.save();
        ctx.fillStyle = '#FFFFFF';
        ctx.shadowBlur = 5;
        ctx.shadowColor = '#87CEEB';

        ctx.beginPath();
        ctx.arc(this.x + 10, this.y + 10, 8, 0, Math.PI * 2);
        ctx.arc(this.x + 20, this.y + 8, 10, 0, Math.PI * 2);
        ctx.arc(this.x + 30, this.y + 10, 8, 0, Math.PI * 2);
        ctx.arc(this.x + 15, this.y + 15, 6, 0, Math.PI * 2);
        ctx.arc(this.x + 25, this.y + 15, 6, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }
}

class Bird {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 30;
        this.height = 20;
        this.vx = (Math.random() - 0.5) * 100;
        this.vy = (Math.random() - 0.5) * 50;
        this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
    }

    update(deltaTime) {
        const dt = deltaTime / 1000;
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        if (this.x < 0 || this.x > 1170) this.vx *= -1;
        if (this.y < 0 || this.y > 580) this.vy *= -1;

        this.x = Math.max(0, Math.min(this.x, 1170));
        this.y = Math.max(0, Math.min(this.y, 580));
    }

    render(ctx) {
        ctx.save();
        ctx.fillStyle = this.color;

        ctx.beginPath();
        ctx.ellipse(this.x + 15, this.y + 10, 12, 8, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#000';
        ctx.fillRect(this.x + 20, this.y + 8, 2, 2);

        ctx.fillStyle = '#FFA500';
        ctx.beginPath();
        ctx.moveTo(this.x + 25, this.y + 12);
        ctx.lineTo(this.x + 30, this.y + 10);
        ctx.lineTo(this.x + 25, this.y + 8);
        ctx.fill();

        ctx.restore();
    }
}

class Tornado {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 25;
        this.height = 60;
        this.angle = 0;
        this.colors = ['#FF69B4', '#9370DB', '#00CED1', '#FFD700'];
    }

    update(deltaTime) {
        this.angle += deltaTime * 0.01;
    }

    render(ctx) {
        ctx.save();
        ctx.translate(this.x + this.width/2, this.y + this.height/2);
        ctx.rotate(this.angle);

        for (let i = 0; i < 4; i++) {
            ctx.fillStyle = this.colors[i];
            const radius = (4 - i) * 6;
            ctx.beginPath();
            ctx.ellipse(0, i * 15 - 30, radius, 8, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }
}

class PowerUp {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.width = 25;
        this.height = 25;
        this.type = type;
        this.pulse = 0;
        this.colors = ['#00BFFF', '#FFD700', '#9370DB'];
        this.names = ['Speed', 'Invincible', 'Invisible'];
    }

    render(ctx) {
        this.pulse += 0.1;
        const scale = 1 + Math.sin(this.pulse) * 0.2;

        ctx.save();
        ctx.translate(this.x + this.width/2, this.y + this.height/2);
        ctx.scale(scale, scale);

        ctx.fillStyle = this.colors[this.type];
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.colors[this.type];

        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
            const angle = (i * Math.PI * 2) / 5;
            const x = Math.cos(angle) * 12;
            const y = Math.sin(angle) * 12;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }
}

class Platform {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 100;
        this.height = 5;
        this.timer = 2000;
    }

    update(deltaTime) {
        this.timer -= deltaTime;
        return this.timer > 0;
    }

    render(ctx) {
        ctx.save();
        ctx.globalAlpha = Math.max(0.3, this.timer / 2000);
        ctx.fillStyle = '#FFFFFF';
        ctx.shadowBlur = 5;
        ctx.shadowColor = '#87CEEB';
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.restore();
    }
}

window.addEventListener('load', () => {
    new ElliotsGame();
});

    </script>
</body>
</html>
